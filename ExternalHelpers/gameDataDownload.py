import requests
import json 
print("go")
payload =["27174983867561dc6cd4e41790d2bb84b51421df",{"code":"using System;\nusing OceanOfCode.Model;\nusing OceanOfCode.Agent;\nusing OceanOfCode.Services;\nusing System.Collections.Generic;\nusing OceanOfCode.Actions;\nusing System.Collections;\nusing System.ComponentModel;\nusing System.Text;\nusing System.Linq;\nusing System.IO;\n\n\n // 20/04/2020 07:44\n\n\nnamespace OceanOfCode\n{\n    public static class Constants\n    {\n        public const bool Local = false;\n\n        public const bool DebugOn = true;\n        \n        public const bool ForInput = true;\n\n        public static readonly Random Random = new Random(123);\n\n        public const string Move = \"MOVE\";\n\n        public const string Surface = \"SURFACE\";\n\n        public const string Silence = \"SILENCE\";\n\n        public const string Sonar = \"SONAR\";\n\n        public const string Torpedo = \"TORPEDO\";\n    }\n}\n\nnamespace OceanOfCode\n{\n    public class Game\n    {\n        public Game()\n        {\n            Players = new[] { new Player(0), new Player(1) };\n        }\n\n        public Map Map { get; set; }\n\n        public Player[] Players { get; }\n\n        public Player Me { get; set; }\n\n        public void SetMe(int id)\n        {\n            Me = Players[id];\n        }\n    }\n}\n\n\nnamespace OceanOfCode\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            var game = new Game();\n            Io.Initialize(game);\n\n\n            var position = GetStartingPosition(game);\n            Io.WriteLine($\"{position.X} {position.Y}\");\n\n            var agent = new ReactAgent(game);\n            while (true)\n            {\n                Io.ReadTurn(game, agent);\n                Io.WriteLine(agent.GetAction());\n            }\n        }\n\n        private static Cell GetStartingPosition(Game game)\n        {\n            Cell position = new Cell(0,0);\n            if (game.Map.IsValid(position))\n            {\n                return position;\n            }\n            position = new Cell(0, 14);\n            if (game.Map.IsValid(position))\n            {\n                return position;\n            }\n            position = new Cell(14, 0);\n            if (game.Map.IsValid(position))\n            {\n                return position;\n            }\n            position = new Cell(14, 14);\n            if (game.Map.IsValid(position))\n            {\n                return position;\n            }\n            while (true)\n            {\n                position = new Cell(Constants.Random.Next(15), Constants.Random.Next(15));\n                if (game.Map.IsValid(position))\n                {\n                    return position;\n                }\n            }\n        }\n    }\n}\nnamespace OceanOfCode.Actions\n{\n    public interface IAction\n    {\n        string GetAction();\n    }\n}\n\nnamespace OceanOfCode.Actions\n{\n    public class Move : IAction\n    {\n        private readonly Direction _direction;\n\n        public Move(Direction direction)\n        {\n            _direction = direction;\n        }\n\n        public string GetAction()\n        {\n            return $\"{Constants.Move} {_direction.ToString()[0]}\";\n        }\n    }\n}\nnamespace OceanOfCode.Actions\n{\n    class Surface : IAction\n    {\n        public string GetAction()\n        {\n            return Constants.Surface;\n        }\n    }\n}\n\n\nnamespace OceanOfCode.Agent\n{\n    public class ReactAgent\n    {\n        private readonly Player _myPlayer;\n\n        private readonly FloodFill _floodFill;\n\n        private readonly OpponentTracking _opponentTracking;\n\n        private readonly Game _game;\n\n        public ReactAgent(Game game)\n        {\n            _myPlayer = game.Me;\n            _game = game;\n            _opponentTracking = new OpponentTracking(_game.Map);\n            _opponentTracking.InitializePossibleOptions();\n            _floodFill = new FloodFill(_game.Map);\n        }\n\n        public string GetAction()\n        {\n            var actions = new List<IAction>();\n\n            //if (ShouldFireTorpedo())\n            //{\n            //    return $\"TORPEDO {_game.Opponent.Position.X} {_game.Opponent.Position.Y}\";\n            //}\n\n            var direction = GetMoveDirection();\n            if (direction == Direction.Unknown)\n            {\n                actions.Add(new Surface());\n                _myPlayer.PreviousPositions.Clear();\n            }\n            else\n            {\n                actions.Add(new Move(direction));\n            }\n\n\n            var ret = string.Empty;\n            for (var index = 0; index < actions.Count; index++)\n            {\n                var action = actions[index];\n                ret += action.GetAction();\n                if (index != actions.Count - 1)\n                {\n                    ret += \" \";\n                }\n            }\n\n            return ret;\n            //return \"MOVE N TORPEDO\";\n        }\n\n        //private bool ShouldFireTorpedo()\n        //{\n        //    Io.Debug(_game.Opponent.ToString());\n        //    return _myPlayer.IsTorpedoCharged() && ManhattanDistance(_myPlayer.Position, _game.Opponent.Position) <= 4;\n        //}\n\n        public float ManhattanDistance(Cell position1, Cell position2)\n        {\n            Io.Debug(position1.ToString());\n            Io.Debug(position2.ToString());\n            return Math.Abs(position1.X - position1.X) + Math.Abs(position1.Y - position2.Y);\n        }\n\n        private Direction GetMoveDirection()\n        {\n            var bestScore = int.MinValue;\n            var bestDirection = Direction.Unknown;\n\n            foreach (var neighbour in _myPlayer.Position.Neighbours)\n            {\n                if (_myPlayer.PreviousPositions.Contains(neighbour.Value))\n                {\n                    continue;\n                }\n                var size = _floodFill.FindOpenArea(neighbour.Value, _myPlayer.PreviousPositions);\n                if (size > bestScore)\n                {\n                    bestScore = size;\n                    bestDirection = neighbour.Key;\n                }\n            }\n            return bestDirection;\n        }\n\n        public void ParseOpponentOrders(string opponentOrders)\n        {\n            _opponentTracking.ParseOrders(opponentOrders);\n        }\n    }\n}\n\nnamespace OceanOfCode.Model\n{\n    public class Cell\n    {\n        public Cell(int x, int y)\n        {\n            X = x;\n            Y = y;\n            Type = CellType.Unknown;\n        }\n\n        public Cell(int x, int y, CellType type)\n        {\n            X = x;\n            Y = y;\n            Type = type;\n            Neighbours = new Dictionary<Direction, Cell>();\n            TorpedoTargets = new HashSet<Cell>();\n        }\n\n        public int X { get; }\n\n        public int Y { get; }\n\n        public CellType Type { get; }\n\n        public Dictionary<Direction, Cell> Neighbours { get; }\n\n        public HashSet<Cell> TorpedoTargets { get; }\n\n        public override string ToString()\n        {\n            return $\"x:{X} y:{Y}\";\n        }\n\n        protected bool Equals(Cell other)\n        {\n            return X == other.X && Y == other.Y;\n        }\n\n        public override bool Equals(object obj)\n        {\n            if (ReferenceEquals(null, obj))\n            {\n                return false;\n            }\n\n            if (ReferenceEquals(this, obj))\n            {\n                return true;\n            }\n\n            if (obj.GetType() != GetType())\n            {\n                return false;\n            }\n\n            return Equals((Cell)obj);\n        }\n\n        public override int GetHashCode()\n        {\n            return 31 * X + 17 * Y;\n        }\n\n        \n    }\n}\nnamespace OceanOfCode.Model\n{\n    public enum CellType\n    {\n        Unknown = 0,\n\n        Sea = 1,\n\n        Island = 2\n    }\n}\n\nnamespace OceanOfCode.Model\n{\n    public enum Direction\n    {\n        Unknown = 0,\n\n        North = 1,\n\n        South = 2,\n\n        East = 3,\n\n        West = 4\n    }\n\n    public static class DirectionExtensions\n    {\n        public static Direction FromChar(char ch)\n        {\n            if (ch == 'E')\n            {\n                return Direction.East;\n            }\n            else if (ch == 'W')\n            {\n                return Direction.West;\n            }\n            else if (ch == 'N')\n            {\n                return Direction.North;\n            }\n            else if (ch == 'S')\n            {\n                return Direction.South;\n            }\n\n            throw new InvalidEnumArgumentException();\n        }\n    }\n}\n\n\nnamespace OceanOfCode.Model\n{\n    public class Map\n    {\n        public int Width { get; }\n\n        public int Height { get; }\n\n        public Cell[,] Cells { get; }\n\n        public Map(int width, int height)\n        {\n            Width = width;\n            Height = height;\n            Cells = new Cell[height, width];\n        }\n\n        public void Build(int row, string line)\n        {\n            for (var index = 0; index < line.Length; index++)\n            {\n                var ch = line[index];\n\n                var cellType = CellType.Sea;\n                if (ch == 'x')\n                {\n                    cellType = CellType.Island;\n                }\n\n                Cells[row, index] = new Cell(index, row, cellType);\n            }\n        }\n\n        public override string ToString()\n        {\n            var sb = new StringBuilder();\n            for (var i = 0; i < Height; i++)\n            {\n                for (var j = 0; j < Width; j++)\n                {\n                    if (Cells[i, j].Type == CellType.Sea)\n                    {\n                        sb.Append('.');\n                    }\n                    else if (Cells[i, j].Type == CellType.Island)\n                    {\n                        sb.Append('x');\n                    }\n                }\n\n                sb.AppendLine();\n            }\n\n            return sb.ToString();\n        }\n\n        public bool IsValid(Cell cell)\n        {\n            if (IsOutOfBounds(cell.X, cell.Y))\n            {\n                return false;\n            }\n\n            var cellType = Cells[cell.Y, cell.X].Type;\n\n            return cellType == CellType.Sea;\n        }\n\n        public void SetupCells()\n        {\n            for (var i = 0; i < Height; i++)\n            {\n                for (var j = 0; j < Width; j++)\n                {\n                    CheckAndAddNeighbour(Cells[i, j], j, i - 1, Direction.North);\n                    CheckAndAddNeighbour(Cells[i, j], j, i + 1, Direction.South);\n                    CheckAndAddNeighbour(Cells[i, j], j - 1, i, Direction.West);\n                    CheckAndAddNeighbour(Cells[i, j], j + 1, i, Direction.East);\n                    CheckAndAddTorpedoLocations(Cells[i, j], Direction.North);\n                    CheckAndAddTorpedoLocations(Cells[i, j], Direction.South);\n                    CheckAndAddTorpedoLocations(Cells[i, j], Direction.West);\n                    CheckAndAddTorpedoLocations(Cells[i, j], Direction.East);\n                }\n            }\n\n            var sb = new StringBuilder();\n            for (var i = 0; i < Height; i++)\n            {\n                for (var j = 0; j < Width; j++)\n                {\n                    sb.Append($\"{Cells[i, j].TorpedoTargets.Count}  \");\n                }\n\n                sb.AppendLine();\n            }\n\n            Io.Debug(sb.ToString());\n        }\n\n        private void CheckAndAddNeighbour(\n            Cell currentCell,\n            int x,\n            int y,\n            Direction direction)\n        {\n            if (IsOutOfBounds(x, y))\n            {\n                return;\n            }\n\n            var newCell = Cells[y, x];\n            if (IsValid(newCell))\n            {\n                currentCell.Neighbours.Add(direction, newCell);\n            }\n        }\n\n        private void CheckAndAddTorpedoLocations(Cell currentCell, Direction direction)\n        {\n            var x = -1;\n            var y = -1;\n            for (var i = 1; i <= 4; i++)\n            {\n                switch (direction)\n                {\n                    case Direction.North:\n                        y = currentCell.Y - i;\n                        break;\n                    case Direction.South:\n                        y = currentCell.Y + i;\n                        break;\n                    case Direction.East:\n                        x = currentCell.X + i;\n                        break;\n                    case Direction.West:\n                        x = currentCell.X - i;\n                        break;\n                }\n\n                if (IsOutOfBounds(x, y))\n                {\n                    return;\n                }\n\n                var newCell = Cells[y, x];\n                if (!IsValid(newCell))\n                {\n                    return;\n                }\n\n                currentCell.TorpedoTargets.Add(newCell);\n            }\n        }\n\n        private bool IsOutOfBounds(int x, int y)\n        {\n            if (y < 0 || y >= 15 || x < 0 || x >= 15)\n            {\n                return true;\n            }\n\n            return false;\n        }\n    }\n}\n\nnamespace OceanOfCode.Model\n{\n    public class Player\n    {\n        private int _silenceCooldown;\n\n        private int _torpedoCooldown;\n\n        private int _sonarCooldown;\n\n        public Player(int id)\n        {\n            Id = id;\n            PreviousPositions = new HashSet<Cell>();\n        }\n\n        public int Id { get; }\n\n        public int Life { get; set; }\n\n        public Cell Position { get; set; }\n\n        public HashSet<Cell> PreviousPositions { get; }\n\n        public void Initialize(\n            Cell position,\n            int life,\n            int torpedoCooldown,\n            int sonarCooldown,\n            int silenceCooldown,\n            int mineCooldown)\n        {\n            Position = position;\n            Life = life;\n            _torpedoCooldown = torpedoCooldown;\n            _sonarCooldown = sonarCooldown;\n            _silenceCooldown = silenceCooldown;\n\n            PreviousPositions.Add(Position);\n        }\n\n        public bool IsTorpedoCharged()\n        {\n            return _torpedoCooldown == 0;\n        }\n\n        public bool IsSonarCharged()\n        {\n            return _sonarCooldown == 0;\n        }\n\n        public bool IsSilenceCharged()\n        {\n            return _silenceCooldown == 0;\n        }\n    }\n}\n\n\nnamespace OceanOfCode.Services\n{\n    public class FloodFill\n    {\n        private readonly Map _map;\n\n        public FloodFill(Map map)\n        {\n            _map = map;\n        }\n\n        public int FindOpenArea(Cell position, HashSet<Cell> previousPositions)\n        {\n            var seen = new HashSet<Cell>();\n            var open = new List<Cell>();\n\n            seen.Add(position);\n            open.Add(position);\n\n            while (open.Any())\n            {\n                var nextCell = open.First();\n                open.RemoveAt(0);\n\n                foreach (var neighbour in nextCell.Neighbours)\n                {\n                    var cell = neighbour.Value;\n                    if (!previousPositions.Contains(cell) && seen.Add(cell))\n                    {\n                        open.Add(cell);\n                    }\n                }\n            }\n\n            return seen.Count;\n        }\n    }\n}\n\n\nnamespace OceanOfCode.Services\n{\n    public static class Io\n    {\n        private static StreamReader file;\n\n        public static void Initialize(Game game)\n        {\n            if (Constants.Local)\n            {\n                file = new StreamReader(@\".\\in.txt\");\n            }\n\n            var inputs = ReadLine().Split(' ');\n            var width = int.Parse(inputs[0]);\n            var height = int.Parse(inputs[1]);\n\n            var myId = int.Parse(inputs[2]);\n\n            game.Map = new Map(width, height);\n\n            for (var i = 0; i < game.Map.Height; i++)\n            {\n                var line = ReadLine();\n                game.Map.Build(i, line);\n            }\n\n            game.Map.SetupCells();\n            game.SetMe(myId);\n        }\n\n        public static void ReadTurn(Game game, ReactAgent agent)\n        {\n            var inputs = ReadLine().Split(' ');\n            var x = int.Parse(inputs[0]);\n            var y = int.Parse(inputs[1]);\n            var myLife = int.Parse(inputs[2]);\n            var oppLife = int.Parse(inputs[3]);\n            var torpedoCooldown = int.Parse(inputs[4]);\n            var sonarCooldown = int.Parse(inputs[5]);\n            var silenceCooldown = int.Parse(inputs[6]);\n            var mineCooldown = int.Parse(inputs[7]);\n            var sonarResult = ReadLine();\n            var opponentOrders = ReadLine();\n            game.Me.Initialize(game.Map.Cells[y,x],\n                               myLife,\n                               torpedoCooldown,\n                               sonarCooldown,\n                               silenceCooldown,\n                               mineCooldown);\n            agent.ParseOpponentOrders(opponentOrders);\n        }\n\n        public static void Debug(string output)\n        {\n            if (Constants.DebugOn)\n            {\n                Console.Error.WriteLine(output);\n            }\n        }\n\n        public static void WriteLine(string output)\n        {\n            Console.WriteLine(output);\n        }\n\n        private static string ReadLine()\n        {\n            if (Constants.Local)\n            {\n                return file.ReadLine();\n            }\n            else\n            {\n                var input = Console.ReadLine();\n                if (Constants.ForInput)\n                {\n                    Debug(\"IN\");\n                    Debug(input);\n                    Debug(\"/IN\");\n                }\n                else\n                {\n                    Debug(input);\n                }\n\n                return input;\n            }\n        }\n    }\n}\n\n\nnamespace OceanOfCode.Services\n{\n    public class OpponentTracking\n    {\n        private readonly Map _map;\n\n        private List<Cell> _possiblePositions;\n\n        public OpponentTracking(Map map)\n        {\n            _map = map;\n            _possiblePositions = new List<Cell>();\n        }\n\n        public void ParseOrders(string orders)\n        {\n            var tokens = orders.Split(new[] { ' ', '|' }, StringSplitOptions.RemoveEmptyEntries);\n            foreach (var token in tokens)\n            {\n                Io.Debug(token);\n            }\n\n            if (tokens[0] == Constants.Move)\n            {\n                ParseMove(tokens[1]);\n                Io.Debug($\"possible positions {_possiblePositions.Count}\");\n                if (_possiblePositions.Count < 10)\n                {\n                    DebugPositions(_possiblePositions);\n                }\n            }\n            else if (tokens[0] == Constants.Surface)\n            {\n                Io.Debug($\"SURFACE possible positions {_possiblePositions.Count}\");\n                var region = Convert.ToInt32(tokens[1]);\n                var xMin = (region - 1) % 3 * 5;\n                var xMax = xMin + 4;\n                var yMin = (region - 1) / 3 * 5;\n                var yMax = yMin + 4;\n                Io.Debug($\"Region {region} : {xMin} {yMin} : {xMax} {yMax}\");\n                var positions = new HashSet<Cell>();\n                for (var i = xMin; i <= xMax; i++)\n                {\n                    for (var j = yMin; j < yMax; j++)\n                    {\n                        positions.Add(_map.Cells[j, i]);\n                    }\n                }\n\n                var next = new HashSet<Cell>();\n                foreach (var possiblePosition in _possiblePositions)\n                {\n                    if (positions.Contains(possiblePosition))\n                    {\n                        next.Add(possiblePosition);\n                    }\n                }\n\n                _possiblePositions = next.ToList();\n            }\n        }\n\n        private void ParseMove(string moveDirection)\n        {\n            var next = new HashSet<Cell>();\n            var dir = DirectionExtensions.FromChar(moveDirection[0]);\n            foreach (var possiblePosition in _possiblePositions)\n            {\n                if (possiblePosition.Neighbours.ContainsKey(dir))\n                {\n                    next.Add(possiblePosition.Neighbours[dir]);\n                }\n            }\n\n            _possiblePositions = next.ToList();\n        }\n\n        public void InitializePossibleOptions()\n        {\n            for (var j = 0; j < _map.Height; j++)\n            {\n                for (var i = 0; i < _map.Width; i++)\n                {\n                    var cell = _map.Cells[i, j];\n                    if (_map.IsValid(cell))\n                    {\n                        _possiblePositions.Add(cell);\n                    }\n                }\n            }\n\n            Io.Debug($\"positions {_possiblePositions.Count}\");\n        }\n\n        private void DebugPositions(IReadOnlyCollection<Cell> positions)\n        {\n            Io.Debug($\"positions {positions.Count}\");\n            foreach (var possiblePosition in positions)\n            {\n                Io.Debug(possiblePosition.ToString());\n            }\n        }\n    }\n}","programmingLanguageId":"C#","multi":{"agentsIds":[-1,-2],"gameOptions":"seed=-8696451144768787500\n"}}]


referer = "https://www.codingame.com/ide/27174983867561dc6cd4e41790d2bb84b51421df"


cookie = "_ga=GA1.1.1630631741.1582746373; _ga=GA1.2.1630631741.1582746373; rememberMe=1506970e7a28f168d0db9769bf52d2ea016c711; _fbp=fb.1.1584837655245.1512366443; _hjid=6d9a8b4d-006b-49aa-9310-504737ae0f6c; _hjIncludedInSample=1; _hjUserAttributesHash=995805a10738aa198ccbf3299b2c8436; _gid=GA1.2.362645380.1586974749; _gid=GA1.1.362645380.1586974749; wisepops=%7B%22csd%22%3A1%2C%22popups%22%3A%7B%7D%2C%22sub%22%3A0%2C%22ucrn%22%3A9%2C%22cid%22%3A%2238179%22%2C%22v%22%3A4%7D; cgSession=6e064662-f671-449e-8848-a626fac9a8ba; wisepops_visits=%5B%222020-04-17T22%3A39%3A55.984Z%22%2C%222020-04-17T06%3A39%3A18.641Z%22%2C%222020-04-16T21%3A49%3A49.788Z%22%2C%222020-04-16T21%3A46%3A11.901Z%22%5D; wisepops_session=%7B%22arrivalOnSite%22%3A%222020-04-17T22%3A39%3A55.984Z%22%2C%22mtime%22%3A%222020-04-17T22%3A39%3A57.390Z%22%2C%22pageviews%22%3A1%2C%22popups%22%3A%7B%7D%2C%22src%22%3Anull%2C%22utm%22%3A%7B%7D%7D; amplitude_id_ecc0b9f76710f07825ed40270d4623e5codingame.com=eyJkZXZpY2VJZCI6IjcyNGEwNGIzLWU1YjQtNDc4MS04YTBhLTYyYzRiYzRiZDE3OVIiLCJ1c2VySWQiOiIxNTA2OTcwIiwib3B0T3V0IjpmYWxzZSwic2Vzc2lvbklkIjoxNTg3MTc3MTE1NjQxLCJsYXN0RXZlbnRUaW1lIjoxNTg3MTgwMzI3MjAzLCJldmVudElkIjo4NywiaWRlbnRpZnlJZCI6MTY5LCJzZXF1ZW5jZU51bWJlciI6MjU2fQ==; AWSALB=uKY7LEFdrMASjMubw0d5b3mu26jJaFMt9/s115KIboK/MIhlJ5WqkHXJ/+V/XlMIs2hJ0PYAAsLOKZhzChmcv5cMuHNxCK5YJxXvMJpzEN54vKqxwt8BZAIaIC0n; AWSALBCORS=uKY7LEFdrMASjMubw0d5b3mu26jJaFMt9/s115KIboK/MIhlJ5WqkHXJ/+V/XlMIs2hJ0PYAAsLOKZhzChmcv5cMuHNxCK5YJxXvMJpzEN54vKqxwt8BZAIaIC0n"
headers = {'Content-type':'application/json;charset=UTF-8', 
            'Accept':'application/json, text/plain, */*',
            'Referer': referer,
            'Cookie': cookie}
r = requests.post("https://www.codingame.com/services/TestSession/play", 
                    data=json.dumps(payload),
                    headers=headers)
data = r.json()['frames']

with open("../c#/OceanOfCode/temp.txt", 'w') as output_file:
    for key in data:
        if 'stderr' in key:
            output = key['stderr']
            output_file.write(output)
            output_file.write("\n")
			
with open("../c#/OceanOfCode/temp.txt", 'r') as input_file:
    with open("../c#/OceanOfCode/in.txt", 'w') as output_file:
        writeLine = False
        lines = input_file.readlines()
        for i, line in enumerate(lines):
            line = line.rstrip()
            if line == "IN":
                writeLine = True
            elif line == "/IN":
                writeLine = False
            elif writeLine:   
                output_file.write(line + "\n")

