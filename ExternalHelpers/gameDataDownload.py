import requests
import json 
print("go")
payload =["501199198ef1a790c7c13354ca0a29a462e3954",{"code":"#ifndef _AI_H\n#define _AI_H\n\n#ifndef _CONSTANTS_H\n#define _CONSTANTS_H\n\n#include <list>\n#include <map>\n#include <vector>\n\nstruct stBomb;\nstruct stTile;\n\ntypedef std::list<stTile*> TileList;\ntypedef std::list<const stTile*> ConstTileList;\ntypedef std::vector<stBomb> BombList;\n\nnamespace TileMainType\n{\n  enum Type\n  {\n    None = -1,\n    Clear,\n    Breakable,\n    Marked,\n    Bomb,\n    Exploding,\n    Wall,\n    UnSafe,\n    Player\n  };\n}\n\nnamespace TileSubType\n{\n  enum Type\n  {\n    None = -1,\n    ItemExtraRange,\n    ItemExtraBomb,\n  };\n}\n\nconst int BOMBFUSE = 8;\n\ntypedef std::map<TileMainType::Type, TileList> TileTypeMap;\n\n#endif  // !_CONSTANTS_H\n\nclass cGameState;\n\nclass cAI\n{\npublic:\n  cAI(cGameState* const pGamestate, int ID);\n  void GenerateNavMap();\n  void MakeMove(int x, int y, int bombRange);\n\nprivate:\n  void changeNavGroup(int from, int to);\n  void GetAccessibleTiles(const stTile& fromTile, ConstTileList& accessibleTiles);\n  bool GetRouteToTile(const stTile& fromTile, const stTile* const pToTile);\n  void BFSCheck(int x, int y, bool** ppVisited, const ConstTileList& accessibleTiles, ConstTileList& queue);\n  void BFSCheckToGetAccessibleTiles(int x, int y, int navGroup, bool** ppVisited, ConstTileList& queue);\n\nprivate:\n  cGameState* const m_pGamestate;\n  int m_ID;\n};\n\n#endif  // !_AI_H\n\n#ifndef _INCLUDES_H\n#define _INCLUDES_H\n\n#include <assert.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <algorithm>\n#include <cctype>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <list>\n\n\n#define DEBUGPRINT(format, ...) fprintf(stderr, format, ##__VA_ARGS__)\n#define MS0(x) memset(x, 0, sizeof(x))\n#define SORT(a, n) sort(begin(a), begin(a) + n)\n#define REVERSE(a, n) reverse(begin(a), begin(a) + n)\n#define ll long long\n#define sp system(\"pause\")\n\n#endif  // _INCLUDES_H\n\n#ifndef _UTILS_H\n#define _UTILS_H\n\ntemplate <typename T>\nT SquaredDistance(T x1, T y1, T x2, T y2)\n{\n  T deltaX = x2 - x1;\n  T deltaY = y2 - y1;\n  return (deltaX * deltaX + deltaY * deltaY);\n}\n\ntemplate <typename Interface>\ninline void SafeDeleteArray(Interface** ppArrayToDelete)\n{\n  if (*ppArrayToDelete != NULL)\n  {\n    delete[](*ppArrayToDelete);\n    (*ppArrayToDelete) = NULL;\n  }\n}\n\ntemplate <typename Interface>\ninline void SafeDelete(Interface** ppInterfaceToDelete)\n{\n  if (*ppInterfaceToDelete != NULL)\n  {\n    delete (*ppInterfaceToDelete);\n    (*ppInterfaceToDelete) = NULL;\n  }\n}\n\nvoid ConvertNumber(ll number, int newBase, std::vector<int>& convertedNumber);\n\n#endif  // !_UTILS_H\n\n\nvoid ConvertNumber(ll number, int newBase, std::vector<int>& convertedNumber)\n{\n  ll remainder = 0;\n  ll tempNumber = number;\n  convertedNumber.clear();\n\n  tempNumber = number;\n  while (tempNumber > 0)\n  {\n    remainder = tempNumber % newBase;\n    tempNumber = tempNumber / newBase;\n    convertedNumber.push_back(remainder);\n  }\n}\n\n#ifndef _GAMESTATE_H\n#define _GAMESTATE_H\n\n\nclass cGameState\n{\npublic:\n  cGameState(int width, int height);\n  ~cGameState();\n  int GetWidth() const { return m_width; }\n  int GetHeight() const { return m_height; }\n  stTile& GetTileAt(int x, int y);\n  void SetTileSubType(int x, int y, TileSubType::Type subType);\n  void CreateGrid();\n  void PrintGrid() const;\n  void Update();\n  void GetTilesInBombRange(int x, int y, int bombRange, TileTypeMap& tiles);\n  void AddBomb(int x, int y, int owner, int bombRange);\n\nprivate:\n  void GetTilesInBombDir(int x, int y, int xdir, int ydir, int bombRange, TileTypeMap& tiles);\n\nprivate:\n  int m_width;\n  int m_height;\n  stTile** m_ppTileMap;\n  BombList m_bombs;\n  int m_noOfActiveBombs;\n};\n#endif  // !_GAMESTATE_H\n\n#ifndef _BOMB_H\n#define _BOMB_H\nstruct stBomb\n{\n  int m_owner;\n  int m_fuse;\n  int m_range;\n  int m_X;\n  int m_Y;\n\n  stBomb(int owner, int range, int x, int y, int fuse)\n    : m_fuse(fuse)\n    , m_owner(owner)\n    , m_range(range)\n    , m_X(x)\n    , m_Y(y)\n  {\n  }\n\n  void Reset(int owner, int range, int x, int y, int fuse)\n  {\n    m_fuse = fuse;\n    m_owner = owner;\n    m_range = range;\n    m_X = x;\n    m_Y = y;\n  }\n};\n#endif  // !_BOMB_H\n\n#ifndef _HSUTILS_H\n#define _HSUTILS_H\n\n\nTileMainType::Type GetSquareType(char c);\nchar GetChar(TileMainType::Type type, TileSubType::Type subType);\n#endif  // !_HSUTILS_H\n\n\nTileMainType::Type GetSquareType(char c)\n{\n  switch (c)\n  {\n    case '.':\n      return TileMainType::Clear;\n    case '0':\n    case '1':\n    case '2':\n      return TileMainType::Breakable;\n    case 'X':\n      return TileMainType::Wall;\n  }\n}\n\nchar GetChar(TileMainType::Type type, TileSubType::Type subType)\n{\n  switch (type)\n  {\n    case TileMainType::Breakable:\n      return '0';\n    case TileMainType::Bomb:\n      return 'B';\n    case TileMainType::Marked:\n      return 'M';\n    case TileMainType::Exploding:\n      return 'E';\n    case TileMainType::Wall:\n      return 'X';\n    case TileMainType::Clear:\n      switch (subType)\n      {\n        case TileSubType::ItemExtraRange:\n          return 'R';\n        case TileSubType::ItemExtraBomb:\n          return 'P';\n        default:\n          return '.';\n      };\n  }\n}\n\n#ifndef _TILE_H\n#define _TILE_H\n\n\nstruct stTile\n{\n  TileMainType::Type m_Type;\n  TileSubType::Type m_subType;\n  int m_NavGroup;\n  int m_X;\n  int m_Y;\n\n  stTile()\n    : m_Type(TileMainType::None)\n    , m_subType(TileSubType::None)\n    , m_NavGroup(0)\n  {\n  }\n\n  bool IsWalkable() const\n  {\n    return m_Type == TileMainType::Clear || m_Type == TileMainType::Exploding || m_Type == TileMainType::UnSafe;\n  }\n\n  bool IsUnsafe() const\n  {\n    return m_Type == TileMainType::Bomb || m_Type == TileMainType::Exploding || m_Type == TileMainType::UnSafe;\n  }\n};\n#endif  // !_TILE_H\n\n\nusing namespace std;\n\ncGameState::cGameState(int width, int height)\n  : m_width(width)\n  , m_height(height)\n  , m_noOfActiveBombs(0)\n{\n  m_ppTileMap = new stTile*[m_width];\n  for (int x = 0; x < m_width; x++)\n  {\n    m_ppTileMap[x] = new stTile[m_height];\n  }\n}\n\ncGameState::~cGameState()\n{\n  for (int i = 0; i < m_height; i++)\n  {\n    SafeDeleteArray(&(m_ppTileMap[i]));\n  }\n  SafeDeleteArray(&m_ppTileMap);\n}\n\nvoid cGameState::PrintGrid() const\n{\n}\n\nvoid cGameState::CreateGrid()\n{\n  for (int y = 0; y < m_height; y++)\n  {\n    string row;\n    getline(cin, row);\n    DEBUGPRINT(\"%s\\n\", row.data());\n    for (int x = 0; x < row.length(); x++)\n    {\n      m_ppTileMap[x][y].m_X = x;\n      m_ppTileMap[x][y].m_Y = y;\n      TileMainType::Type type = GetSquareType(row[x]);\n      if (type == TileMainType::Clear)\n      {\n        if (m_ppTileMap[x][y].m_Type == TileMainType::Exploding || m_ppTileMap[x][y].m_Type == TileMainType::UnSafe ||\n            m_ppTileMap[x][y].m_Type == TileMainType::Bomb)\n        {\n          continue;\n        }\n      }\n      if (type == TileMainType::Breakable)\n      {\n        if (m_ppTileMap[x][y].m_Type == TileMainType::Marked)\n        {\n          continue;\n        }\n      }\n      m_ppTileMap[x][y].m_Type = type;\n    }\n  }\n\n  PrintGrid();\n}\n\nvoid cGameState::Update()\n{\n  if (m_noOfActiveBombs > 0)\n  {\n    for (auto iter = m_bombs.begin(); iter != m_bombs.end(); iter++)\n    {\n      stBomb& bomb = *iter;\n      if (bomb.m_fuse > 0)\n      {\n        bomb.m_fuse--;\n        if (bomb.m_fuse < 4)\n        {\n          TileTypeMap tilesMap;\n          GetTilesInBombRange(bomb.m_X, bomb.m_Y, bomb.m_range, tilesMap);\n          if (bomb.m_fuse == 0)\n          {\n            TileList tiles = tilesMap[TileMainType::Exploding];\n            for (auto iter = tiles.begin(); iter != tiles.end(); iter++)\n            {\n              (*iter)->m_Type = TileMainType::Clear;\n            }\n            m_ppTileMap[bomb.m_X][bomb.m_Y].m_Type = TileMainType::Clear;\n            m_noOfActiveBombs--;\n          }\n          else\n          {\n            TileList tiles = tilesMap[TileMainType::UnSafe];\n            for (auto iter = tiles.begin(); iter != tiles.end(); iter++)\n            {\n              (*iter)->m_Type = TileMainType::Exploding;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nstTile& cGameState::GetTileAt(int x, int y)\n{\n  return m_ppTileMap[x][y];\n}\n\nvoid cGameState::SetTileSubType(int x, int y, TileSubType::Type subType)\n{\n  m_ppTileMap[x][y].m_subType = subType;\n}\n\nvoid cGameState::GetTilesInBombDir(int x, int y, int xdir, int ydir, int bombRange, TileTypeMap& tiles)\n{\n  for (int i = 1; i < bombRange; ++i)\n  {\n    int xx = x + (i * xdir);\n    int yy = y + (i * ydir);\n\n    if (xx < 0 || xx >= m_width || yy < 0 || yy >= m_height)\n    {\n      break;\n    }\n\n    stTile& tile = m_ppTileMap[xx][yy];\n    if (tile.m_Type == TileMainType::Breakable || tile.m_Type == TileMainType::Clear ||\n        tile.m_Type == TileMainType::Exploding || tile.m_Type == TileMainType::UnSafe)\n    {\n      tiles[tile.m_Type].push_back(&tile);\n    }\n    if (tile.m_Type == TileMainType::Wall || tile.m_Type == TileMainType::Breakable ||\n        tile.m_Type == TileMainType::Marked || tile.m_Type == TileMainType::Bomb)\n    {\n      break;\n    }\n  }\n}\n\nvoid cGameState::GetTilesInBombRange(int x, int y, int bombRange, TileTypeMap& tiles)\n{\n  tiles.clear();\n  GetTilesInBombDir(x, y, 1, 0, bombRange, tiles);\n  GetTilesInBombDir(x, y, -1, 0, bombRange, tiles);\n  GetTilesInBombDir(x, y, 0, 1, bombRange, tiles);\n  GetTilesInBombDir(x, y, 0, -1, bombRange, tiles);\n}\n\nvoid cGameState::AddBomb(int x, int y, int owner, int bombRange)\n{\n  m_ppTileMap[x][y].m_Type = TileMainType::Bomb;\n  TileTypeMap bombTiles;\n  GetTilesInBombRange(x, y, bombRange, bombTiles);\n\n  TileList breakableTiles = bombTiles[TileMainType::Breakable];\n  for (auto iter = breakableTiles.begin(); iter != breakableTiles.end(); iter++)\n  {\n    (*iter)->m_Type = TileMainType::Marked;\n  }\n  TileList unsafeTiles = bombTiles[TileMainType::Clear];\n  for (auto iter = unsafeTiles.begin(); iter != unsafeTiles.end(); iter++)\n  {\n    (*iter)->m_Type = TileMainType::UnSafe;\n  }\n\n  bool found = false;\n  int fuse = BOMBFUSE;\n  for (auto iter = m_bombs.begin(); iter != m_bombs.end(); iter++)\n  {\n    stBomb& bomb = *iter;\n    if (bomb.m_fuse <= 0)\n    {\n      found = true;\n      (*iter).Reset(owner, bombRange, x, y, fuse);\n      break;\n    }\n  }\n  if (!found)\n  {\n    m_bombs.push_back(stBomb(owner, bombRange, x, y, fuse));\n  }\n  m_noOfActiveBombs++;\n}\n\n\nusing namespace std;\n\ncAI::cAI(cGameState* const pGamestate, int ID)\n  : m_pGamestate(pGamestate)\n  , m_ID(ID)\n{\n}\n\nvoid cAI::GenerateNavMap()\n{\n  int group = 0;\n  int next_group = 0;\n  bool incrementGroup = true;\n\n  for (int x = 0; x < m_pGamestate->GetWidth(); x++)\n  {\n    for (int y = 0; y < m_pGamestate->GetHeight(); y++)\n    {\n      stTile& tile = m_pGamestate->GetTileAt(x, y);\n      if (!tile.IsWalkable())\n      {\n        incrementGroup = true;\n        continue;\n      }\n      if (incrementGroup)\n      {\n        group = ++next_group;\n        incrementGroup = false;\n      }\n      tile.m_NavGroup = group;\n      if (x > 0)\n      {\n        int left_group = m_pGamestate->GetTileAt(x - 1, y).m_NavGroup;\n        if (left_group == 0)\n        {\n          continue;\n        }\n        int mingroup = min(tile.m_NavGroup, left_group);\n        int maxGroup = max(tile.m_NavGroup, left_group);\n        changeNavGroup(maxGroup, mingroup);\n        group = mingroup;\n      }\n    }\n    incrementGroup = true;\n  }\n\n}\n\nvoid cAI::changeNavGroup(int from, int to)\n{\n  for (int x = 0; x < m_pGamestate->GetWidth(); ++x)\n  {\n    for (int y = 0; y < m_pGamestate->GetHeight(); ++y)\n    {\n      stTile& tile = m_pGamestate->GetTileAt(x, y);\n      if (tile.m_NavGroup == from)\n      {\n        tile.m_NavGroup = to;\n      }\n    }\n  }\n}\n\nvoid cAI::MakeMove(int x, int y, int bombRange)\n{\n  ConstTileList moveTiles;\n  const stTile& currentTile = m_pGamestate->GetTileAt(x, y);\n  GetAccessibleTiles(currentTile, moveTiles);\n  int count = 0;\n\n  const stTile* destTile = nullptr;\n  for (auto iterMoveTiles = moveTiles.begin(); iterMoveTiles != moveTiles.end(); iterMoveTiles++)\n  {\n    const stTile* const pMoveTile = *iterMoveTiles;\n\n    TileTypeMap bombTiles;\n    m_pGamestate->GetTilesInBombRange(pMoveTile->m_X, pMoveTile->m_Y, bombRange, bombTiles);\n    if (bombTiles[TileMainType::Breakable].size() > 0)\n    {\n      if (!pMoveTile->IsUnsafe() && GetRouteToTile(currentTile, pMoveTile))\n      {\n        destTile = pMoveTile;\n        break;\n      }\n    }\n  }\n  string action = \"MOVE\";\n  x = 0;\n  y = 0;\n\n  if (destTile != nullptr)\n  {\n    x = destTile->m_X;\n    y = destTile->m_Y;\n  }\n\n  if (destTile == &currentTile)\n  {\n    action = \"BOMB\";\n  }\n\n  cout << action << \" \" << x << \" \" << y << endl;\n}\nvoid cAI::GetAccessibleTiles(const stTile& fromTile, ConstTileList& accessibleTiles)\n{\n  bool** ppVisited = new bool*[m_pGamestate->GetWidth()];\n  for (int x = 0; x < m_pGamestate->GetWidth(); x++)\n  {\n    ppVisited[x] = new bool[m_pGamestate->GetHeight()];\n    for (int y = 0; y < m_pGamestate->GetHeight(); y++)\n    {\n      ppVisited[x][y] = false;\n    }\n  }\n\n  list<const stTile*> queue;\n\n  queue.push_back(&fromTile);\n  ppVisited[fromTile.m_X][fromTile.m_Y] = true;\n  while (!queue.empty())\n  {\n    const stTile* pCurrentTile = queue.front();\n    if (pCurrentTile->m_Y > 0)\n    {\n      BFSCheckToGetAccessibleTiles(pCurrentTile->m_X, pCurrentTile->m_Y - 1, pCurrentTile->m_NavGroup, ppVisited,\n                                   queue);\n    }\n    if (pCurrentTile->m_Y < m_pGamestate->GetHeight() - 1)\n    {\n      BFSCheckToGetAccessibleTiles(pCurrentTile->m_X, pCurrentTile->m_Y + 1, pCurrentTile->m_NavGroup, ppVisited,\n                                   queue);\n    }\n    if (pCurrentTile->m_X > 0)\n    {\n      BFSCheckToGetAccessibleTiles(pCurrentTile->m_X - 1, pCurrentTile->m_Y, pCurrentTile->m_NavGroup, ppVisited,\n                                   queue);\n    }\n    if (pCurrentTile->m_X < m_pGamestate->GetWidth() - 1)\n    {\n      BFSCheckToGetAccessibleTiles(pCurrentTile->m_X + 1, pCurrentTile->m_Y, pCurrentTile->m_NavGroup, ppVisited,\n                                   queue);\n    }\n    accessibleTiles.push_back(pCurrentTile);\n    queue.pop_front();\n  }\n\n  for (int x = 0; x < m_pGamestate->GetWidth(); x++)\n  {\n    SafeDeleteArray(&(ppVisited[x]));\n  }\n  SafeDeleteArray(&ppVisited);\n}\n\nbool cAI::GetRouteToTile(const stTile& fromTile, const stTile* const pToTile)\n{\n  if (fromTile.m_NavGroup != pToTile->m_NavGroup)\n  {\n    return false;\n  }\n\n  bool** ppVisited = new bool*[m_pGamestate->GetWidth()];\n  for (int x = 0; x < m_pGamestate->GetWidth(); x++)\n  {\n    ppVisited[x] = new bool[m_pGamestate->GetHeight()];\n    for (int y = 0; y < m_pGamestate->GetHeight(); y++)\n    {\n      ppVisited[x][y] = false;\n    }\n  }\n\n  ConstTileList accessibleTiles;\n  GetAccessibleTiles(fromTile, accessibleTiles);\n  list<const stTile*> queue;\n\n  queue.push_back(&fromTile);\n  ppVisited[fromTile.m_X][fromTile.m_Y] = true;\n\n  bool found = false;\n  while (!found && !queue.empty())\n  {\n    const stTile* pCurrentTile = queue.front();\n    if (pCurrentTile == pToTile)\n    {\n      found = true;\n      break;\n    }\n    if (pCurrentTile->m_Y > 0)\n    {\n      BFSCheck(pCurrentTile->m_X, pCurrentTile->m_Y - 1, ppVisited, accessibleTiles, queue);\n    }\n    if (pCurrentTile->m_Y < m_pGamestate->GetHeight() - 1)\n    {\n      BFSCheck(pCurrentTile->m_X, pCurrentTile->m_Y + 1, ppVisited, accessibleTiles, queue);\n    }\n    if (pCurrentTile->m_X > 0)\n    {\n      BFSCheck(pCurrentTile->m_X - 1, pCurrentTile->m_Y, ppVisited, accessibleTiles, queue);\n    }\n    if (pCurrentTile->m_X < m_pGamestate->GetWidth() - 1)\n    {\n      BFSCheck(pCurrentTile->m_X + 1, pCurrentTile->m_Y, ppVisited, accessibleTiles, queue);\n    }\n    queue.pop_front();\n  }\n\n  for (int x = 0; x < m_pGamestate->GetWidth(); x++)\n  {\n    SafeDeleteArray(&(ppVisited[x]));\n  }\n  SafeDeleteArray(&ppVisited);\n  return found;\n}\n\nvoid cAI::BFSCheckToGetAccessibleTiles(int x, int y, int navGroup, bool** ppVisited, ConstTileList& queue)\n{\n  if (x < 0 || x >= m_pGamestate->GetWidth() || y < 0 || y >= m_pGamestate->GetHeight())\n  {\n    return;\n  }\n  stTile& tile = m_pGamestate->GetTileAt(x, y);\n\n  if (tile.m_NavGroup == navGroup && !ppVisited[tile.m_X][tile.m_Y])\n  {\n    ppVisited[tile.m_X][tile.m_Y] = true;\n    if (tile.IsWalkable())\n    {\n      queue.push_back(&tile);\n    }\n  }\n}\n\nvoid cAI::BFSCheck(int x, int y, bool** ppVisited, const ConstTileList& accessibleTiles, ConstTileList& queue)\n{\n  stTile& tile = m_pGamestate->GetTileAt(x, y);\n  if (tile.IsWalkable() && !ppVisited[tile.m_X][tile.m_Y])\n  {\n    ppVisited[tile.m_X][tile.m_Y] = true;\n    ConstTileList::const_iterator iterator = find(accessibleTiles.begin(), accessibleTiles.end(), &tile);\n    if (iterator == accessibleTiles.end())\n    {\n      return;\n    }\n    queue.push_back(*iterator);\n  }\n}\n\n\nusing namespace std;\n\nint main()\n{\n\n  int width;\n  int height;\n  int myId;\n  cin >> width >> height >> myId;\n  cin.ignore();\n  DEBUGPRINT(\"%d %d %d\\n\", width, height, myId);\n\n  cGameState gameState(width, height);\n  cAI bot(&gameState, myId);\n\n  int myPosX = 0;\n  int myPosY = 0;\n  int myBombRange = 3;\n  // game loop\n  while (1)\n  {\n    gameState.CreateGrid();\n    int entities;\n    cin >> entities;\n    cin.ignore();\n    DEBUGPRINT(\"%d\\n\", entities);\n    gameState.Update();\n    for (int i = 0; i < entities; i++)\n    {\n      int entityType;\n      int owner;\n      int x;\n      int y;\n      int param1;\n      int param2;\n      cin >> entityType >> owner >> x >> y >> param1 >> param2;\n      DEBUGPRINT(\"%d %d %d %d %d %d\\n\", entityType, owner, x, y, param1, param2);\n      cin.ignore();\n\n      myBombRange = 3;\n\n      if (entityType == 0 && owner == myId)\n      {\n        myPosX = x;\n        myPosY = y;\n      }\n      else if (entityType == 1)\n      {\n        if (owner == myId)\n        {\n          myBombRange = param2;\n        }\n        if (param1 == BOMBFUSE)\n        {\n          gameState.AddBomb(x, y, owner, param2);\n        }\n      }\n      else if (entityType == 2)\n      {\n        TileSubType::Type type = param1 == 1 ? TileSubType::ItemExtraRange : TileSubType::ItemExtraBomb;\n        gameState.SetTileSubType(x, y, type);\n      }\n    }\n    bot.GenerateNavMap();\n    bot.MakeMove(myPosX, myPosY, myBombRange);\n  }\n}\n\n","programmingLanguageId":"C++","multi":{"agentsIds":[716580,715604,-1],"gameOptions":"seed=952581943\nboxes=36\n"}}]
referer = "https://www.codingame.com/ide/501199198ef1a790c7c13354ca0a29a462e3954"
cookie = "remcg=be9sHNTvhnAzMVH72YgPTysANXpNkIZoB4mRogy3cw3XVY9b9hBvmi9sDIHx4Pm60AJmtlcZSWKsu5Dt07Xex9x0PYNP/A1fpzrBVfQCwmLbdn99gs08qw3uJ0ZVOcZp/ZTRoWnACccshX5KndUAOzI8a8i52G86DIzGqpo8bXOGNQMbM6jwrn45VFpSyp6uEz8Eadfw23E66dIUo2IZYhZuWInM1FCYMQSPAzgBO06/n7uPVdz/t55w/hWRHTlcSBsBFjXj/Xs4ekgkx2NhQalizXhS1H5qo1/AZb92q8XD+aLwXt630ZCjriD4jGQmlPcuu08B1hCZX5nCciou4211h3TM/0duDebb2QdRd7I9nPXSsot8X8WrucTLVXU5SpEYbVCHb+xJuM0OEy3q7IEZkWeqx3oWrmwSP+aFCtZgy3evq31jPAOq1r8l65DNOkAKj8EP55lll3Zn2v/yYlyKg7mqaD04hq2dyPacVylh10JqPzhXmVKqcAkJx1igMmR/Xpm5D27JJMsA1AyfvrAZi+Fn5ZKG67dxbwldM/elR9fI1FqpDZk9IceI6NtZr8Pu0s82zd3IFNn4kUfyLQ==; fbm_165331130336219=base_domain=.www.codingame.com; godfatherId=835636; __insp_wid=1125741027; __insp_nv=true; __insp_targlpu=https%3A%2F%2Fwww.codingame.com%2Fwork%2Fsolutions%2Fcoding-skill-assessment; __insp_targlpt=Coding%20Skill%20Assessment%20through%20automated%20programming%20tests; __insp_norec_sess=true; __insp_slim=1473651752919; _hp2_id.379513634=%7B%22userId%22%3A%222740793447589959%22%2C%22pageviewId%22%3A%220918398609119793%22%2C%22sessionId%22%3A%221019571767553824%22%2C%22identity%22%3Anull%2C%22trackerVersion%22%3A%223.0%22%7D; _ga=GA1.2.517899547.1470200165; JSESSIONID=84640566ED151D3740A6911043DCC7BC; AWSELB=49DF73731CB4F82B161CA4E04E72C058E44897F09E4ED61DDC54543F2410666140C9A273D0DD95554604DA288374F77F137396C594A274B18E725D463BDD09374368E8771C; _gat=1; mp_367d5a11a4032fa993d1535dc63b0bc7_mixpanel=%7B%22distinct_id%22%3A%20%221564ec231261fd-032d639bae8cf3-404c0428-1fa400-1564ec2312777d%22%2C%22%24initial_referrer%22%3A%20%22https%3A%2F%2Ft.co%2FDv2QvmeB1A%22%2C%22%24initial_referring_domain%22%3A%20%22t.co%22%2C%22__mps%22%3A%20%7B%7D%2C%22__mpso%22%3A%20%7B%7D%2C%22__mpa%22%3A%20%7B%7D%2C%22__mpu%22%3A%20%7B%7D%2C%22__mpap%22%3A%20%5B%5D%2C%22Mx%20IP%22%3A%20%22103.5.28.251%22%2C%22User%20ID%22%3A%201506970%2C%22A%2FB%20-%20160725%20-%20Signup%20Join%20Now%22%3A%20%22BJoinNow%22%2C%22A%2FB%20-%20160725%20-%20New%20game%20page%22%3A%20%22OldGamePage%22%2C%22Current%20page%22%3A%20%22IDE%22%2C%22%24search_engine%22%3A%20%22google%22%2C%22__alias%22%3A%201506970%2C%22A%2FB%20-%20160725%20-%20CSBDescent%22%3A%20%22DescentCSB%22%2C%22A%2FB%20-%20160831%20-%20Contest%20SlideShow%22%3A%20%22ContestDescriptionA%22%2C%22A%2FB%20-%20160909%20-%20Contest%20SlideShow%22%3A%20%22ContestDescriptionB%22%7D; mp_mixpanel__c=0"
headers = {'Content-type':'application/json;charset=UTF-8', 
            'Accept':'application/json, text/plain, */*',
            'Referer': referer,
            'Cookie': cookie}
r = requests.post("https://www.codingame.com/services/TestSessionRemoteService/play", 
                    data=json.dumps(payload),
                    headers=headers)
data = r.json()['success']['frames']

with open("../c++/prj/temp.txt", 'w') as output_file:
    for key in data:
        if 'stderr' in key:
            output = key['stderr']
            output_file.write(output)
            output_file.write("\n")
			
with open("../c++/prj/temp.txt", 'r') as input_file:
    with open("../c++/prj/in.txt", 'w') as output_file:
        writeLine = False
        lines = input_file.readlines()
        for i, line in enumerate(lines):
            line = line.rstrip()
            if line == "IN":
                writeLine = True
            elif line == "/IN":
                writeLine = False
            elif writeLine:   
                output_file.write(line + "\n")

